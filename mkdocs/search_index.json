{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nThe CODAL runtime provides an easy to use environment for programming a number of devices\nin the C/C++ language, written by Lancaster University. It contains device drivers for hardware capabilities supported on a number devices,\nand also a suite of runtime mechanisms to make programming an embedded device easier and more flexible. These\nrange from control of the LED matrix display to peer-to-peer radio communication.\n\n\nIn addition to supporting development in C/C++, the runtime is also designed specifically to support\nhigher level languages provided by our partners that target physical computing and computer science education. It is currently used as a support library for \nMicrosoft MakeCode\n\n\nOn these pages you will find guidance on how to get started with CODAL, including setting up and configuring your development environment.\n\n\nGetting Started\n\n\n\n\nInstall\n the required tools.\n\n\nSelect your target.\n\n\nPROGRAM!\n\n\n\n\nHere is some sample code Circuit Playground to get you started:\n\n\n#include \nCircuitPlayground.h\n\n\nCircuitPlayground cplay;\n\nint main()\n{\n    while(1)\n    {\n        cplay.io.led.setDigitalValue(1);\n        cplay.sleep(500);\n        cplay.io.led.setDigitalValue(1);\n        cplay.sleep(500);\n    }\n\n    release_fiber();\n}\n\n\n\n\nWhat is cplay?\n\n\ncplay\n is an instance of the CircuitPlayground class, a software model of the Circuit Playground hardware. This abstraction provides a really simple way to interact with the various components of the device itself.\n\n\nThis simplicity can be seen with this line of code:\n\n\ncplay.io.led.setDigitalValue(1);\n\n\n\n\nThis line sets the LED indicator on the device.\n\n\nWhat is a fiber and why do we release it?\n\n\nFibers are lightweight threads used by the runtime to perform operations asynchronously.\n\n\nThe function call \nrelease_fiber();\n is recommended at the end of main to release the main fiber, and enter\nthe scheduler indefinitely as you may have other fibers running elsewhere in the code.\nIt also means that the processor will enter a power efficient sleep if there are\nno other processes running.\n\n\nIf this line is omitted, your program will cease all execution.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "The CODAL runtime provides an easy to use environment for programming a number of devices\nin the C/C++ language, written by Lancaster University. It contains device drivers for hardware capabilities supported on a number devices,\nand also a suite of runtime mechanisms to make programming an embedded device easier and more flexible. These\nrange from control of the LED matrix display to peer-to-peer radio communication.  In addition to supporting development in C/C++, the runtime is also designed specifically to support\nhigher level languages provided by our partners that target physical computing and computer science education. It is currently used as a support library for  Microsoft MakeCode  On these pages you will find guidance on how to get started with CODAL, including setting up and configuring your development environment.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Install  the required tools.  Select your target.  PROGRAM!   Here is some sample code Circuit Playground to get you started:  #include  CircuitPlayground.h \n\nCircuitPlayground cplay;\n\nint main()\n{\n    while(1)\n    {\n        cplay.io.led.setDigitalValue(1);\n        cplay.sleep(500);\n        cplay.io.led.setDigitalValue(1);\n        cplay.sleep(500);\n    }\n\n    release_fiber();\n}", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#what-is-cplay", 
            "text": "cplay  is an instance of the CircuitPlayground class, a software model of the Circuit Playground hardware. This abstraction provides a really simple way to interact with the various components of the device itself.  This simplicity can be seen with this line of code:  cplay.io.led.setDigitalValue(1);  This line sets the LED indicator on the device.", 
            "title": "What is cplay?"
        }, 
        {
            "location": "/#what-is-a-fiber-and-why-do-we-release-it", 
            "text": "Fibers are lightweight threads used by the runtime to perform operations asynchronously.  The function call  release_fiber();  is recommended at the end of main to release the main fiber, and enter\nthe scheduler indefinitely as you may have other fibers running elsewhere in the code.\nIt also means that the processor will enter a power efficient sleep if there are\nno other processes running.  If this line is omitted, your program will cease all execution.", 
            "title": "What is a fiber and why do we release it?"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\nAutomatic installation.\n\n\nThis software has its grounding on the founding principles of \nYotta\n, the simplest install path would be to install their tools via their handy installer.\n\n\nDocker\n\n\nA \ndocker image\n is available that contains toolchains used to build codal targets. A wrapper \nDockerfile\n is available that can be used to build your project with ease.\n\n\nThen follow the build steps listed below.\n\n\nManual installation\n\n\n\n\nInstall \ngit\n, ensure it is available on your platforms path.\n\n\nInstall the relevant compilation toolchain for your desired platform:\n\n\narm-none-eabi-*\n command line utilities for ARM based devices\n\n\navr-gcc\n, \navr-binutils\n, \navr-libc\n for AVR based devices\n\n\nxtensa-esp32-*\n for xtensa based devices.\n\n\n\n\n\n\nInstall \nCMake\n(Cross platform make), this is the entirety of the build system.\n\n\nIf on Windows, install ninja.\n\n\n\n\n\n\nInstall \nPython 2.7\n (if you are unfamiliar with CMake), python scripts are used to simplify the build process.\n\n\nClone this repository\n\n\n\n\nBuilding\n\n\n\n\nGenerate or create a \ncodal.json\n file\n\n\npython build.py ls\n lists all available targets\n\n\npython build.py \ntarget-name\n generates a codal.json file for a given target\n\n\n\n\n\n\n\n\nIn the root of this repository type \npython build.py\n the \n-c\n option cleans before building.\n\n\n\n\nIf you are not using python:\n\n\nWindows:\n\n\nIn the root of the repository make a build folder.\n\n\ncd build\n\n\ncmake .. -G \"Ninja\" -DCMAKE_BUILD_TYPE=RelWithDebInfo\n\n\nninja\n\n\n\n\n\n\nMac:\n\n\nIn the root of the repository make a build folder.\n\n\ncd build\n\n\ncmake .. -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=RelWithDebInfo\n\n\nmake\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe hex file will be placed at the location specified by \ncodal.json\n, by default this is the root.", 
            "title": "Installation Guide"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#automatic-installation", 
            "text": "This software has its grounding on the founding principles of  Yotta , the simplest install path would be to install their tools via their handy installer.", 
            "title": "Automatic installation."
        }, 
        {
            "location": "/installation/#docker", 
            "text": "A  docker image  is available that contains toolchains used to build codal targets. A wrapper  Dockerfile  is available that can be used to build your project with ease.  Then follow the build steps listed below.", 
            "title": "Docker"
        }, 
        {
            "location": "/installation/#manual-installation", 
            "text": "Install  git , ensure it is available on your platforms path.  Install the relevant compilation toolchain for your desired platform:  arm-none-eabi-*  command line utilities for ARM based devices  avr-gcc ,  avr-binutils ,  avr-libc  for AVR based devices  xtensa-esp32-*  for xtensa based devices.    Install  CMake (Cross platform make), this is the entirety of the build system.  If on Windows, install ninja.    Install  Python 2.7  (if you are unfamiliar with CMake), python scripts are used to simplify the build process.  Clone this repository", 
            "title": "Manual installation"
        }, 
        {
            "location": "/installation/#building", 
            "text": "Generate or create a  codal.json  file  python build.py ls  lists all available targets  python build.py  target-name  generates a codal.json file for a given target     In the root of this repository type  python build.py  the  -c  option cleans before building.   If you are not using python:  Windows:  In the root of the repository make a build folder.  cd build  cmake .. -G \"Ninja\" -DCMAKE_BUILD_TYPE=RelWithDebInfo  ninja    Mac:  In the root of the repository make a build folder.  cd build  cmake .. -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=RelWithDebInfo  make         The hex file will be placed at the location specified by  codal.json , by default this is the root.", 
            "title": "Building"
        }, 
        {
            "location": "/devices/", 
            "text": "Devices\n\n\nA number of devices (or targets) are currently supported in CODAL, to obtain a full list of targets type:\n\n\npython build.py ls\n\n\n\n\nTo generate the \ncodal.json\n for a target listed by the ls command, please run:\n\n\npython build.py \ntarget-name\n\n\n\n\n\nPlease note you may need to remove the libraries folder if your previous build relied on similar dependencies.\n\n\nConfiguration\n\n\nBelow is an example of how to configure codal to build the \ncodal-circuit-playground\n target, example applications will automatically be loaded into the \"source\" folder:\n\n\n{\n    \ntarget\n:{\n        \nname\n:\ncodal-circuit-playground\n,\n        \nurl\n:\nhttps://github.com/lancaster-university/codal-circuit-playground\n,\n        \nbranch\n:\nmaster\n,\n        \ntype\n:\ngit\n\n    }\n}\n\n\n\n\nFor more targets, read the targets section below.\n\n\nConfiguration Options\n\n\nIf you would like to override or define any additional configuration options (\n#define's\n) that are used by the supporting libraries, the codal build system allows the addition of a config field in \ncodal.json\n:\n\n\n{\n    \ntarget\n:{\n        \nname\n:\ncodal-circuit-playground\n,\n        \nurl\n:\nhttps://github.com/lancaster-university/codal-circuit-playground\n,\n        \nbranch\n:\nmaster\n,\n        \ntype\n:\ngit\n\n    },\n    \nconfig\n:{\n        \nNUMBER_ONE\n:1\n    },\n    \napplication\n:\nsource\n,\n    \noutput_folder\n:\n.\n\n}\n\n\n\n\nThe above example will translate \n\"NUMBER_ONE\":1\n into: \n#define NUMBER_ONE     1\n and force include it during compilation. You can also specify alternate application or output folders.\n\n\nTargets\n\n\nArduino Uno\n\n\nThis target specifies the arduino uno which is driven by an atmega328p.\n\n\ncodal.json specification\n\n\n{\n    \ntarget\n:{\n        \nname\n:\ncodal-arduino-uno\n,\n        \nurl\n:\nhttps://github.com/lancaster-university/codal-arduino-uno\n,\n        \nbranch\n:\nmaster\n,\n        \ntype\n:\ngit\n\n    }\n}\n\n\n\n\n\nThis target depends on:\n\n\n\n\ncodal-core\n provides the core CODAL abstractions\n\n\ncodal-atmega328p\n implements basic CODAL components (I2C, Pin, Serial, Timer)\n\n\n\n\nBrainPad\n\n\nThis target specifies the BrainPad which is driven by a STM32F.\n\n\ncodal.json specification\n\n\n{\n    \ntarget\n:{\n        \nname\n:\ncodal-brainpad\n,\n        \nurl\n:\nhttps://github.com/lancaster-university/codal-brainpad\n,\n        \nbranch\n:\nmaster\n,\n        \ntype\n:\ngit\n\n    }\n}\n\n\n\n\nThis target depends on:\n\n\n\n\ncodal-core\n provides the core CODAL abstractions\n\n\ncodal-mbedos\n implements required CODAL basic components (Timer, Serial, Pin, I2C, ...) using Mbed\n\n\n\n\nCircuit Playground\n\n\nThis target specifies the circuit playground which is driven by a SAMD21.\n\n\ncodal.json specification\n\n\n{\n    \ntarget\n:{\n        \nname\n:\ncodal-circuit-playground\n,\n        \nurl\n:\nhttps://github.com/lancaster-university/codal-circuit-playground\n,\n        \nbranch\n:\nmaster\n,\n        \ntype\n:\ngit\n\n    }\n}\n\n\n\n\n\nThis target depends on:\n\n\n\n\ncodal-core\n provides the core CODAL abstractions\n\n\ncodal-mbed\n implements required CODAL basic components (Timer, Serial, Pin, I2C, ...) using Mbed\n\n\ncodal-samd21\n implements SAMD21-specific components (such as USB)\n\n\nmbed-classic\n is a fork of mbed, used by codal-mbed", 
            "title": "Devices"
        }, 
        {
            "location": "/devices/#devices", 
            "text": "A number of devices (or targets) are currently supported in CODAL, to obtain a full list of targets type:  python build.py ls  To generate the  codal.json  for a target listed by the ls command, please run:  python build.py  target-name   Please note you may need to remove the libraries folder if your previous build relied on similar dependencies.", 
            "title": "Devices"
        }, 
        {
            "location": "/devices/#configuration", 
            "text": "Below is an example of how to configure codal to build the  codal-circuit-playground  target, example applications will automatically be loaded into the \"source\" folder:  {\n     target :{\n         name : codal-circuit-playground ,\n         url : https://github.com/lancaster-university/codal-circuit-playground ,\n         branch : master ,\n         type : git \n    }\n}  For more targets, read the targets section below.", 
            "title": "Configuration"
        }, 
        {
            "location": "/devices/#configuration-options", 
            "text": "If you would like to override or define any additional configuration options ( #define's ) that are used by the supporting libraries, the codal build system allows the addition of a config field in  codal.json :  {\n     target :{\n         name : codal-circuit-playground ,\n         url : https://github.com/lancaster-university/codal-circuit-playground ,\n         branch : master ,\n         type : git \n    },\n     config :{\n         NUMBER_ONE :1\n    },\n     application : source ,\n     output_folder : . \n}  The above example will translate  \"NUMBER_ONE\":1  into:  #define NUMBER_ONE     1  and force include it during compilation. You can also specify alternate application or output folders.", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/devices/#targets", 
            "text": "", 
            "title": "Targets"
        }, 
        {
            "location": "/devices/#arduino-uno", 
            "text": "This target specifies the arduino uno which is driven by an atmega328p.", 
            "title": "Arduino Uno"
        }, 
        {
            "location": "/devices/#codaljson-specification", 
            "text": "{\n     target :{\n         name : codal-arduino-uno ,\n         url : https://github.com/lancaster-university/codal-arduino-uno ,\n         branch : master ,\n         type : git \n    }\n}  This target depends on:   codal-core  provides the core CODAL abstractions  codal-atmega328p  implements basic CODAL components (I2C, Pin, Serial, Timer)", 
            "title": "codal.json specification"
        }, 
        {
            "location": "/devices/#brainpad", 
            "text": "This target specifies the BrainPad which is driven by a STM32F.", 
            "title": "BrainPad"
        }, 
        {
            "location": "/devices/#codaljson-specification_1", 
            "text": "{\n     target :{\n         name : codal-brainpad ,\n         url : https://github.com/lancaster-university/codal-brainpad ,\n         branch : master ,\n         type : git \n    }\n}  This target depends on:   codal-core  provides the core CODAL abstractions  codal-mbedos  implements required CODAL basic components (Timer, Serial, Pin, I2C, ...) using Mbed", 
            "title": "codal.json specification"
        }, 
        {
            "location": "/devices/#circuit-playground", 
            "text": "This target specifies the circuit playground which is driven by a SAMD21.", 
            "title": "Circuit Playground"
        }, 
        {
            "location": "/devices/#codaljson-specification_2", 
            "text": "{\n     target :{\n         name : codal-circuit-playground ,\n         url : https://github.com/lancaster-university/codal-circuit-playground ,\n         branch : master ,\n         type : git \n    }\n}  This target depends on:   codal-core  provides the core CODAL abstractions  codal-mbed  implements required CODAL basic components (Timer, Serial, Pin, I2C, ...) using Mbed  codal-samd21  implements SAMD21-specific components (such as USB)  mbed-classic  is a fork of mbed, used by codal-mbed", 
            "title": "codal.json specification"
        }, 
        {
            "location": "/advanced/", 
            "text": "Advanced\n\n\nArchitecture\n\n\nThe CODAL runtime is formed of many libraries, the library common to \nall\n CODAL targets is known as \ncodal-core\n. This library contains common drivers, abstractions for common drivers (driver models), the scheduler and eventing mechanisms, central to the CODAL experience.\n\n\nLibraries\n\n\nLibraries are simply collections of C/C++ files to be used in the final binary. CMakeLists.txt define the contents and dependencies of a library. Here's an example for codal-core:\n\n\ninclude(\n${CODAL_UTILS_LOCATION}\n)\n\ninclude(\n${CODAL_UTILS_LOCATION}\n)\nRECURSIVE_FIND_DIR(INCLUDE_DIRS \n./inc\n \n*.h\n)\nRECURSIVE_FIND_FILE(SOURCE_FILES \n./source\n \n*.c??\n)\n\nexecute_process(WORKING_DIRECTORY \n.\n COMMAND \ngit\n \nlog\n \n--pretty=format:%h\n \n-n\n \n1\n OUTPUT_VARIABLE git_hash)\nexecute_process(WORKING_DIRECTORY \n.\n COMMAND \ngit\n \nrev-parse\n \n--abbrev-ref\n \nHEAD\n OUTPUT_VARIABLE git_branch OUTPUT_STRIP_TRAILING_WHITESPACE)\n\nif (\n${git_branch}\n STREQUAL \nmaster\n)\n    set(CODAL_VERSION_STRING \n${CODAL_VERSION_STRING}\n)\nelse()\n    set(CODAL_VERSION_STRING \n${CODAL_VERSION_STRING}-${git_branch}-g${git_hash}\n)\nendif()\n\nset(CODAL_VERSION_FLAGS \n-DCODAL_VERSION=\\\\\\\n${CODAL_VERSION_STRING}\\\\\\\n)\n\nset (CMAKE_CXX_FLAGS \n${CMAKE_CXX_FLAGS} ${CODAL_VERSION_FLAGS}\n)\n\nadd_library(codal-core\n    ${SOURCE_FILES}\n)\n\ntarget_include_directories(codal-core PUBLIC ${INCLUDE_DIRS})\n\n\n\n\nThere are additional defines and function to help developers write CMakeLists.txt.\n\n\n${CODAL_UTILS_LOCATION}\n defines the location where utility functions are kept, such as \nRECURSIVE_FIND_DIR\n and \nRECURSIVE_FIND_FILE\n useful for finding source and header files.\n\n\nBefore invoking any library \nCMakeLists.txt\n, codal's CMakeLists.txt defines information about the target and toolchain:\n- \nCODAL_TARGET_NAME\n - The name of the current target.\n- \nCODAL_OUTPUT_NAME\n - The name of the output binary.\n- \nCODAL_TARGET_PROCESSOR\n - The name of the target processor.\n- \nCODAL_TARGET_CPU_ARCHITECTURE\n - The architecture of the processor i.e. CortexM0.\n- \nTOOLCHAIN\n - The toolchain e.g. AVR_GCC, ARM_GCC.\n\n\nLibraries can be composed however you desire, however we recommend segmenting includes and source files into respective directories named \"inc\" and \"source\".\n\n\nTargets\n\n\nTargets are libraries with one addition, a \ntarget.json\n.\n\n\nThe CODAL build system uses information in this file to select and configure toolchains, and download dependencies. \ntarget.json\n also contains information required to configure libraries, like mbed, as well as provide device specific definitions for codal-core. The \ntarget.json\n can also configure a post process task, executed from the root of CODAL.\n\n\nBelow is the \ntarget.json\n for the Circuit Playground:\n\n\n{\n    \ndevice\n:\nCIRCUIT_PLAYGROUND\n,\n    \nprocessor\n:\nSAMD21G18A\n,\n    \narchitecture\n:\nCORTEX_M0_PLUS\n,\n    \ntoolchain\n:\nARM_GCC\n,\n    \npost_process\n:\npython ./utils/uf2conv.py -o \nOUTPUT_HEX_DESTINATION\n/\nOUTPUT_HEX_NAME\n.uf2 -c \nOUTPUT_BIN_LOCATION\n,\n    \ngenerate_bin\n:true,\n    \ngenerate_hex\n:true,\n    \nconfig\n:{\n        \nCODAL_TIMESTAMP\n:\nuint64_t\n,\n        \nUSB_MAX_PKT_SIZE\n: 64,\n        \nDEVICE_USB_ENDPOINTS\n:8,\n        \nUSB_DEFAULT_PID\n:\n0x2402\n,\n        \nUSB_DEFAULT_VID\n:\n0x03EB\n,\n        \nUSB_EP_FLAG_NO_AUTO_ZLP\n:\n0x01\n,\n        \nDEVICE_SRAM_BASE\n:\n0x20000000\n,\n        \nDEVICE_SRAM_END\n:\n0x20008000\n,\n        \nDEVICE_STACK_BASE\n:\nDEVICE_SRAM_END\n,\n        \nDEVICE_STACK_SIZE\n:2048,\n        \nTARGET_DEBUG_CLASS\n:\nNOT_IMPLEMENTED\n,\n        \nDEVICE_HEAP_ALLOCATOR\n:1,\n        \nDEVICE_TAG\n:0,\n        \nSCHEDULER_TICK_PERIOD_US\n:6000,\n        \nEVENT_LISTENER_DEFAULT_FLAGS\n:\nMESSAGE_BUS_LISTENER_QUEUE_IF_BUSY\n,\n        \nMESSAGE_BUS_LISTENER_MAX_QUEUE_DEPTH\n:10,\n        \nUSE_ACCEL_LSB\n:0,\n        \nDEVICE_DEFAULT_SERIAL_MODE\n:\nSYNC_SLEEP\n,\n        \nDEVICE_COMPONENT_COUNT\n:30,\n        \nDEVICE_DEFAULT_PULLMODE\n:\nPullMode::None\n,\n        \nDEVICE_PANIC_HEAP_FULL\n:1,\n        \nDEVICE_DMESG\n:1,\n        \nDEVICE_DMESG_BUFFER_SIZE\n:1024,\n        \nCODAL_DEBUG\n:0,\n        \nDEVICE_USB\n:1,\n        \nPROCESSOR_WORD_TYPE\n:\nuint32_t\n\n    },\n    \ndefinitions\n:\n-DCONF_CLOCKS_H_INCLUDED -DGCLK_PERIPHERAL_CLOCK=GCLK_GENERATOR_3 -DDEVICE_ANALOGIN -DDEVICE_ANALOGOUT -DDEVICE_I2C -DDEVICE_I2CSLAVE -DDEVICE_I2C_ASYNCH -DDEVICE_INTERRUPTIN -DDEVICE_PORTIN -DDEVICE_PORTINOUT -DDEVICE_PORTOUT -DDEVICE_RTC -DDEVICE_SERIAL -DDEVICE_SERIAL_ASYNCH -DDEVICE_SERIAL_FC -DDEVICE_SLEEP -DDEVICE_SPI -DDEVICE_PWMOUT -DDEVICE_SPISLAVE -DDEVICE_SPI_ASYNCH -DCONF_CLOCKS_H_INCLUDED -DGCLK_PERIPHERAL_CLOCK=GCLK_GENERATOR_3 -D__SAMD21G18A__ -D__CORTEX_M0PLUS -D__MBED__=1  -DTOOLCHAIN_GCC -DTOOLCHAIN_GCC_ARM -DMBED_OPERATORS -DTARGET_ADAFRUIT_CP_G18A -DI2C_MASTER_CALLBACK_MODE=true -DEXTINT_CALLBACK_MODE=true -DUSART_CALLBACK_MODE=true -DTC_ASYNC=true\n,\n    \ncmake_definitions\n:{\n        \nMBED_LEGACY_TARGET_DEFINITIONS\n:\nADAFRUIT_CP_G18A;Atmel;SAM_CortexM0P;SAMD21\n,\n        \nMBED_LEGACY_TOOLCHAIN\n:\nGCC_ARM;\n\n    },\n    \ncpu_opts\n:\n-mcpu=cortex-m0plus -mthumb\n,\n    \nasm_flags\n:\n-fno-exceptions -fno-unwind-tables --specs=nosys.specs\n,\n    \nc_flags\n:\n-std=c99 --specs=nosys.specs\n,\n    \ncpp_flags\n:\n-std=c++11 -fwrapv -fno-rtti -fno-threadsafe-statics -fno-exceptions -fno-unwind-tables -Wl,--gc-sections -Wl,--sort-common -Wl,--sort-section=alignment\n,\n    \nlinker_flags\n:\n-Wl,--no-wchar-size-warning,-wrap,main\n,\n    \nlibraries\n:[\n        {\n            \nname\n:\ncodal-core\n,\n            \nurl\n:\nhttps://github.com/lancaster-university/codal-core\n,\n            \nbranch\n:\nmaster\n,\n            \ntype\n:\ngit\n\n        },\n        {\n            \nname\n:\nmbed-classic\n,\n            \nurl\n:\nhttps://github.com/lancaster-university/mbed-classic\n,\n            \nbranch\n:\nnew-build-system\n,\n            \ntype\n:\ngit\n\n        },\n        {\n            \nname\n:\ncodal-samd21\n,\n            \nurl\n:\nhttps://github.com/lancaster-university/codal-samd21\n,\n            \nbranch\n:\nmaster\n,\n            \ntype\n:\ngit\n\n        },\n        {\n            \nname\n:\ncodal-mbed\n,\n            \nurl\n:\nhttps://github.com/lancaster-university/codal-mbed\n,\n            \nbranch\n:\nmaster\n,\n            \ntype\n:\ngit\n\n        }\n    ]\n}", 
            "title": "Advanced"
        }, 
        {
            "location": "/advanced/#advanced", 
            "text": "", 
            "title": "Advanced"
        }, 
        {
            "location": "/advanced/#architecture", 
            "text": "The CODAL runtime is formed of many libraries, the library common to  all  CODAL targets is known as  codal-core . This library contains common drivers, abstractions for common drivers (driver models), the scheduler and eventing mechanisms, central to the CODAL experience.", 
            "title": "Architecture"
        }, 
        {
            "location": "/advanced/#libraries", 
            "text": "Libraries are simply collections of C/C++ files to be used in the final binary. CMakeLists.txt define the contents and dependencies of a library. Here's an example for codal-core:  include( ${CODAL_UTILS_LOCATION} )\n\ninclude( ${CODAL_UTILS_LOCATION} )\nRECURSIVE_FIND_DIR(INCLUDE_DIRS  ./inc   *.h )\nRECURSIVE_FIND_FILE(SOURCE_FILES  ./source   *.c?? )\n\nexecute_process(WORKING_DIRECTORY  .  COMMAND  git   log   --pretty=format:%h   -n   1  OUTPUT_VARIABLE git_hash)\nexecute_process(WORKING_DIRECTORY  .  COMMAND  git   rev-parse   --abbrev-ref   HEAD  OUTPUT_VARIABLE git_branch OUTPUT_STRIP_TRAILING_WHITESPACE)\n\nif ( ${git_branch}  STREQUAL  master )\n    set(CODAL_VERSION_STRING  ${CODAL_VERSION_STRING} )\nelse()\n    set(CODAL_VERSION_STRING  ${CODAL_VERSION_STRING}-${git_branch}-g${git_hash} )\nendif()\n\nset(CODAL_VERSION_FLAGS  -DCODAL_VERSION=\\\\\\ ${CODAL_VERSION_STRING}\\\\\\ )\n\nset (CMAKE_CXX_FLAGS  ${CMAKE_CXX_FLAGS} ${CODAL_VERSION_FLAGS} )\n\nadd_library(codal-core\n    ${SOURCE_FILES}\n)\n\ntarget_include_directories(codal-core PUBLIC ${INCLUDE_DIRS})  There are additional defines and function to help developers write CMakeLists.txt.  ${CODAL_UTILS_LOCATION}  defines the location where utility functions are kept, such as  RECURSIVE_FIND_DIR  and  RECURSIVE_FIND_FILE  useful for finding source and header files.  Before invoking any library  CMakeLists.txt , codal's CMakeLists.txt defines information about the target and toolchain:\n-  CODAL_TARGET_NAME  - The name of the current target.\n-  CODAL_OUTPUT_NAME  - The name of the output binary.\n-  CODAL_TARGET_PROCESSOR  - The name of the target processor.\n-  CODAL_TARGET_CPU_ARCHITECTURE  - The architecture of the processor i.e. CortexM0.\n-  TOOLCHAIN  - The toolchain e.g. AVR_GCC, ARM_GCC.  Libraries can be composed however you desire, however we recommend segmenting includes and source files into respective directories named \"inc\" and \"source\".", 
            "title": "Libraries"
        }, 
        {
            "location": "/advanced/#targets", 
            "text": "Targets are libraries with one addition, a  target.json .  The CODAL build system uses information in this file to select and configure toolchains, and download dependencies.  target.json  also contains information required to configure libraries, like mbed, as well as provide device specific definitions for codal-core. The  target.json  can also configure a post process task, executed from the root of CODAL.  Below is the  target.json  for the Circuit Playground:  {\n     device : CIRCUIT_PLAYGROUND ,\n     processor : SAMD21G18A ,\n     architecture : CORTEX_M0_PLUS ,\n     toolchain : ARM_GCC ,\n     post_process : python ./utils/uf2conv.py -o  OUTPUT_HEX_DESTINATION / OUTPUT_HEX_NAME .uf2 -c  OUTPUT_BIN_LOCATION ,\n     generate_bin :true,\n     generate_hex :true,\n     config :{\n         CODAL_TIMESTAMP : uint64_t ,\n         USB_MAX_PKT_SIZE : 64,\n         DEVICE_USB_ENDPOINTS :8,\n         USB_DEFAULT_PID : 0x2402 ,\n         USB_DEFAULT_VID : 0x03EB ,\n         USB_EP_FLAG_NO_AUTO_ZLP : 0x01 ,\n         DEVICE_SRAM_BASE : 0x20000000 ,\n         DEVICE_SRAM_END : 0x20008000 ,\n         DEVICE_STACK_BASE : DEVICE_SRAM_END ,\n         DEVICE_STACK_SIZE :2048,\n         TARGET_DEBUG_CLASS : NOT_IMPLEMENTED ,\n         DEVICE_HEAP_ALLOCATOR :1,\n         DEVICE_TAG :0,\n         SCHEDULER_TICK_PERIOD_US :6000,\n         EVENT_LISTENER_DEFAULT_FLAGS : MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY ,\n         MESSAGE_BUS_LISTENER_MAX_QUEUE_DEPTH :10,\n         USE_ACCEL_LSB :0,\n         DEVICE_DEFAULT_SERIAL_MODE : SYNC_SLEEP ,\n         DEVICE_COMPONENT_COUNT :30,\n         DEVICE_DEFAULT_PULLMODE : PullMode::None ,\n         DEVICE_PANIC_HEAP_FULL :1,\n         DEVICE_DMESG :1,\n         DEVICE_DMESG_BUFFER_SIZE :1024,\n         CODAL_DEBUG :0,\n         DEVICE_USB :1,\n         PROCESSOR_WORD_TYPE : uint32_t \n    },\n     definitions : -DCONF_CLOCKS_H_INCLUDED -DGCLK_PERIPHERAL_CLOCK=GCLK_GENERATOR_3 -DDEVICE_ANALOGIN -DDEVICE_ANALOGOUT -DDEVICE_I2C -DDEVICE_I2CSLAVE -DDEVICE_I2C_ASYNCH -DDEVICE_INTERRUPTIN -DDEVICE_PORTIN -DDEVICE_PORTINOUT -DDEVICE_PORTOUT -DDEVICE_RTC -DDEVICE_SERIAL -DDEVICE_SERIAL_ASYNCH -DDEVICE_SERIAL_FC -DDEVICE_SLEEP -DDEVICE_SPI -DDEVICE_PWMOUT -DDEVICE_SPISLAVE -DDEVICE_SPI_ASYNCH -DCONF_CLOCKS_H_INCLUDED -DGCLK_PERIPHERAL_CLOCK=GCLK_GENERATOR_3 -D__SAMD21G18A__ -D__CORTEX_M0PLUS -D__MBED__=1  -DTOOLCHAIN_GCC -DTOOLCHAIN_GCC_ARM -DMBED_OPERATORS -DTARGET_ADAFRUIT_CP_G18A -DI2C_MASTER_CALLBACK_MODE=true -DEXTINT_CALLBACK_MODE=true -DUSART_CALLBACK_MODE=true -DTC_ASYNC=true ,\n     cmake_definitions :{\n         MBED_LEGACY_TARGET_DEFINITIONS : ADAFRUIT_CP_G18A;Atmel;SAM_CortexM0P;SAMD21 ,\n         MBED_LEGACY_TOOLCHAIN : GCC_ARM; \n    },\n     cpu_opts : -mcpu=cortex-m0plus -mthumb ,\n     asm_flags : -fno-exceptions -fno-unwind-tables --specs=nosys.specs ,\n     c_flags : -std=c99 --specs=nosys.specs ,\n     cpp_flags : -std=c++11 -fwrapv -fno-rtti -fno-threadsafe-statics -fno-exceptions -fno-unwind-tables -Wl,--gc-sections -Wl,--sort-common -Wl,--sort-section=alignment ,\n     linker_flags : -Wl,--no-wchar-size-warning,-wrap,main ,\n     libraries :[\n        {\n             name : codal-core ,\n             url : https://github.com/lancaster-university/codal-core ,\n             branch : master ,\n             type : git \n        },\n        {\n             name : mbed-classic ,\n             url : https://github.com/lancaster-university/mbed-classic ,\n             branch : new-build-system ,\n             type : git \n        },\n        {\n             name : codal-samd21 ,\n             url : https://github.com/lancaster-university/codal-samd21 ,\n             branch : master ,\n             type : git \n        },\n        {\n             name : codal-mbed ,\n             url : https://github.com/lancaster-university/codal-mbed ,\n             branch : master ,\n             type : git \n        }\n    ]\n}", 
            "title": "Targets"
        }
    ]
}